#include "fs.h"

#include <assert.h>
#include <glob.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>

#include "sha-2/sha-256.h"

static int fswalkerr(const char* epath, const int errno) {
  fprintf(stderr, "error accessing `%s`: %d\n", epath, errno);
  return 0; /* continue glob scan */
}

int fswalk(const char* dir, int (*filefn)(const char* fp),
           void (*dirfn)(const char* dp)) {
  char pattern[256]; /* glob pattern format buffer */
  glob_t gres = {0}; /* glob search results */
  int ret;           /* glob return value */

  // ensure pattern has capacity for dir + wildcard suffix
  assert(strlen(dir) < sizeof(pattern));
  snprintf(pattern, sizeof(pattern), "%s/*", dir);

  if ((ret = glob(pattern, GLOB_MARK | GLOB_TILDE, fswalkerr, &gres))) {
    globfree(&gres);
    if (ret == GLOB_NOMATCH) return 0;
    return -1;
  }

#if defined(__FreeBSD__) || defined(__APPLE__)
  const int mc = gres.gl_matchc;
#else
  const int mc = gres.gl_pathc;
#endif

  // invoke process function for each result
  for (int i = 0; i < mc; i++) {
    char* fp = gres.gl_pathv[i];
    const size_t len = strlen(fp);

    // if directory, invoke directory function
    if (fp[len - 1] == '/') {
      // remove the trailing slash generated by GLOB_MARK
      fp[len - 1] = '\0';
      if (dirfn != NULL) dirfn(fp);
    } else if (filefn(gres.gl_pathv[i])) {
      globfree(&gres);
      return -1;
    }
  }

  globfree(&gres);
  return 0;
}

bool fsstateql(const struct fsstat_s* a, const struct fsstat_s* b) {
  return a->lmod == b->lmod && a->fsze == b->fsze;
}

int fsstat(const char* fp, struct fsstat_s* s) {
  struct stat st = {0};
  if (stat(fp, &st)) return -1;
#if defined(__FreeBSD__) || defined(__APPLE__)
  const struct timespec ts = st.st_mtimespec; /* last modified */
#else
  const struct timespec ts = st.st_mtim; /* last modified */
#endif
  s->lmod = ts.tv_sec * 1000 + ts.tv_nsec / 1000000; /* convert to millis */
  s->fsze = st.st_size;                              /* copy file size */
  return 0;
}

#define FSBUFSIZE 8192

int fssum(const char* fp, uint8_t sum[FSSUMBYTES]) {
  FILE* h = NULL;          /* opened file handler */
  struct Sha_256 sha;      /* hashing context */
  uint8_t fbuf[FSBUFSIZE]; /* file read buffer */
  size_t nread;            /* bytes read */

  if ((h = fopen(fp, "rb")) == NULL) return -1;

  // read file in chunks and update hash
  sha_256_init(&sha, sum);
  while ((nread = fread(fbuf, 1, FSBUFSIZE, h)) > 0)
    sha_256_write(&sha, fbuf, nread);
  sha_256_close(&sha);

  fclose(h);
  return 0;
}
